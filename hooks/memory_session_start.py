#!/usr/bin/env python3
"""
Memory Session Start Hook for Claude Code
Hook: SessionStart

Injects session primer when a new session begins.
The primer provides temporal context - when we last spoke,
what we were working on, project status.

Also loads key documentation:
- Global docs (always): CLAUDE_CAPABILITIES.md (skills, hooks, commands inventory)
- Project docs (when in project): SESSION_HANDOFF.md, ROADMAP.md, APP_MAP.md

Note: SESSION_HANDOFF.md is auto-generated by SessionEnd hook.
      Content from SESSION_KICKOFF.md has been consolidated into ROADMAP.md.

The hook receives JSON on stdin:
{
    "session_id": "...",
    "cwd": "/current/working/directory",
    "source": "startup" | "resume" | "clear"
}

Output to stdout is injected as context for the session.

NOTE: Uses only Python standard library (no external dependencies)
"""

import sys
import json
import os
from pathlib import Path
from typing import Optional
from urllib.request import urlopen, Request
from urllib.error import URLError, HTTPError

# Documentation configuration
CLAUDE_HOME = Path.home() / ".claude"

# Global docs - always loaded (relative to ~/.claude/)
# CLAUDE_CAPABILITIES.md is the master inventory of all skills, hooks, commands
GLOBAL_DOCS = [
    ("workflows/CLAUDE_CAPABILITIES.md", "Claude Capabilities", 200),
]

# Project docs - loaded when in a project directory (relative to project root)
# SESSION_HANDOFF.md is auto-generated by SessionEnd hook (session_handoff_generator.py)
# SESSION_KICKOFF.md content has been consolidated into ROADMAP.md
PROJECT_DOCS = [
    ("SESSION_HANDOFF.md", "Session Handoff", 150),
    ("ROADMAP.md", "Project Roadmap", 150),
    ("APP_MAP.md", "App Architecture", 200),
]

# Configuration
MEMORY_API_URL = os.getenv("MEMORY_API_URL", "http://localhost:8765")
DEFAULT_PROJECT_ID = os.getenv("MEMORY_PROJECT_ID", "default")
TIMEOUT_SECONDS = 5


def http_post(url: str, data: dict, timeout: int = 5) -> dict:
    """Make HTTP POST request using only standard library."""
    try:
        json_data = json.dumps(data).encode('utf-8')
        request = Request(
            url,
            data=json_data,
            headers={'Content-Type': 'application/json'},
            method='POST'
        )
        with urlopen(request, timeout=timeout) as response:
            return json.loads(response.read().decode('utf-8'))
    except (URLError, HTTPError, TimeoutError, json.JSONDecodeError):
        return {}


def get_project_id(cwd: str) -> str:
    """
    Determine project ID from working directory.
    Looks for .memory-project.json in cwd or parents.
    """
    path = Path(cwd)

    for parent in [path] + list(path.parents):
        config_file = parent / ".memory-project.json"
        if config_file.exists():
            try:
                with open(config_file) as f:
                    config = json.load(f)
                    return config.get("project_id", DEFAULT_PROJECT_ID)
            except:
                pass

    return path.name or DEFAULT_PROJECT_ID


def find_project_root(cwd: str) -> Optional[Path]:
    """
    Find project root by looking for CLAUDE.md or .git directory.
    Returns None if not in a project.
    """
    path = Path(cwd)

    for parent in [path] + list(path.parents):
        # Stop at home directory
        if parent == Path.home():
            return None
        # Look for project markers
        if (parent / "CLAUDE.md").exists() or (parent / ".git").exists():
            return parent

    return None


def read_doc_file(file_path: Path, max_lines: int = 100) -> str:
    """
    Read a documentation file, truncating if needed.
    Returns empty string if file doesn't exist.
    """
    if not file_path.exists():
        return ""

    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()

        if len(lines) > max_lines:
            content = ''.join(lines[:max_lines])
            content += f"\n... (truncated, {len(lines) - max_lines} more lines)\n"
        else:
            content = ''.join(lines)

        return content.strip()
    except Exception:
        return ""


def load_global_docs() -> str:
    """Load global documentation from ~/.claude/"""
    sections = []

    for rel_path, label, max_lines in GLOBAL_DOCS:
        file_path = CLAUDE_HOME / rel_path
        content = read_doc_file(file_path, max_lines)
        if content:
            sections.append(f"### {label}\n{content}")

    if sections:
        return "## Global Context\n\n" + "\n\n".join(sections)
    return ""


def load_project_docs(project_root: Path) -> str:
    """Load project-specific documentation."""
    sections = []

    for rel_path, label, max_lines in PROJECT_DOCS:
        file_path = project_root / rel_path
        content = read_doc_file(file_path, max_lines)
        if content:
            sections.append(f"### {label}\n{content}")

    if sections:
        return f"## Project: {project_root.name}\n\n" + "\n\n".join(sections)
    return ""


def get_session_primer(session_id: str, project_id: str) -> str:
    """
    Get session primer from memory system.
    
    The primer provides continuity context:
    - When we last spoke
    - What happened in previous session
    - Current project status
    """
    result = http_post(
        f"{MEMORY_API_URL}/memory/context",
        {
            "session_id": session_id,
            "project_id": project_id,
            "current_message": "",  # Empty to get just primer
            "max_memories": 0  # No memories, just primer
        },
        timeout=TIMEOUT_SECONDS
    )
    return result.get("context_text", "")


def register_session(session_id: str, project_id: str):
    """
    Register the session with the memory system.
    This increments the message counter so the inject hook
    knows to retrieve memories instead of the primer.
    """
    http_post(
        f"{MEMORY_API_URL}/memory/process",
        {
            "session_id": session_id,
            "project_id": project_id,
            "metadata": {"event": "session_start"}
        },
        timeout=2
    )


def main():
    """Main hook entry point."""
    # Skip if this is being called from the memory curator subprocess
    if os.getenv("MEMORY_CURATOR_ACTIVE") == "1":
        return

    try:
        # Read input from stdin
        input_data = json.load(sys.stdin)

        session_id = input_data.get("session_id", "unknown")
        cwd = input_data.get("cwd", os.getcwd())
        source = input_data.get("source", "startup")

        # Collect all context sections
        context_parts = []

        # 1. Get session primer from memory system
        project_id = get_project_id(cwd)
        primer = get_session_primer(session_id, project_id)
        if primer:
            context_parts.append(primer)

        # Register session so inject hook knows to get memories, not primer
        register_session(session_id, project_id)

        # 2. Load global documentation (always)
        global_docs = load_global_docs()
        if global_docs:
            context_parts.append(global_docs)

        # 3. Load project documentation (if in a project)
        project_root = find_project_root(cwd)
        if project_root:
            project_docs = load_project_docs(project_root)
            if project_docs:
                context_parts.append(project_docs)

        # Output combined context to stdout
        if context_parts:
            output = "\n\n---\n\n".join(context_parts)
            print(f"# Session Context\n\n{output}")

    except Exception:
        # Never crash
        pass


if __name__ == "__main__":
    main()
